{"meta":{"title":"SictiyLeon","subtitle":"柠檬派","description":null,"author":"sictiy xu","url":"https://www.sictiy.cn/hblog","root":"/hblog/"},"pages":[{"title":"文章分类","date":"2020-03-03T14:35:54.169Z","updated":"2020-01-17T15:42:44.735Z","comments":true,"path":"categories/index.html","permalink":"https://www.sictiy.cn/hblog/categories/index.html","excerpt":"","text":""},{"title":"文章归档","date":"2020-03-03T14:35:54.171Z","updated":"2020-01-17T15:45:06.428Z","comments":true,"path":"archives/index.html","permalink":"https://www.sictiy.cn/hblog/archives/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2019-03-17T02:50:00.000Z","updated":"2020-01-17T15:20:53.692Z","comments":true,"path":"about/index.html","permalink":"https://www.sictiy.cn/hblog/about/index.html","excerpt":"","text":"关于博客基于hexo框架，主题为material-x项目源码：https://github.com/Sictiy/hblog-src2020-01-16 迁移至本站。原站地址：https://sictiyleon.xyz本站github.io部署地址：https://sictiy.github.io/hblog本站华为云部署地址: https://sictiy.cn/hblog 关于我github：https://github.com/Sictiygmail: xlm104600@gmail.comqqmail: sictiy@qq.com"},{"title":"Tags","date":"2019-03-17T07:41:21.000Z","updated":"2020-01-16T15:46:11.507Z","comments":true,"path":"tags/index.html","permalink":"https://www.sictiy.cn/hblog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"singleInstance","slug":"singleInstance-1","date":"2020-03-09T12:59:44.000Z","updated":"2020-03-09T12:59:44.634Z","comments":true,"path":"2020/03/09/singleInstance-1/","link":"","permalink":"https://www.sictiy.cn/hblog/2020/03/09/singleInstance-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"lombok简单使用，简单实现单例注解及修改lombokidea插件支持新增的单例注解","slug":"singleInstance","date":"2020-03-09T12:59:44.000Z","updated":"2020-03-09T12:59:44.672Z","comments":true,"path":"2020/03/09/singleInstance/","link":"","permalink":"https://www.sictiy.cn/hblog/2020/03/09/singleInstance/","excerpt":"之前写java代码，如果要增加一个拥有很多个属性的实体类时，每一个属性都需要写setter方法和getter方法，无疑是平白增加工作量，后来发现可以使用lombok库，通过在类前加注解省去这个费时的步骤。那这么好用的功能到底怎么实现的呢？同样使用场景很多的单例，是不是也可以用同样的原理实现呢？","text":"之前写java代码，如果要增加一个拥有很多个属性的实体类时，每一个属性都需要写setter方法和getter方法，无疑是平白增加工作量，后来发现可以使用lombok库，通过在类前加注解省去这个费时的步骤。那这么好用的功能到底怎么实现的呢？同样使用场景很多的单例，是不是也可以用同样的原理实现呢？ lombok简单使用 这里放一个简单的例子： 12345678910111213141516171819202122232425262728293031323334353637/*** 等级** generated by tool* @since: 2019-12-16*/@Setter@Getter@ToString@NoArgsConstructorpublic class JLevelInfo&#123; /** * */ long id; /** * */ long userId; /** * */ int type; /** * */ int value; /** * */ int level;&#125; 这样就可以不需要手动或自动去写一堆的getter，setter，或是构造函数。具体的用法不多啰嗦，可以随便找一篇文章, 或者进入官网查看。 实现原理 可以猜测，这个lombok其实是在写完代码，到运行字节码中间的某一个时机，坐了某一个编译器编译之外的工作，将字节码变成了增加了代码后的字节码。 通过一番搜索了解到： jdk5时引用注解的同时提供了两种解析方式： 运行时解析 编译时解析 这里使用了编译时解析的JSP 269 Pluggable Annotation Processing API机制，javac 在执行时会调用实现了该api的程序，通过这个程序，我们就可以实现编译器之外的自定义功能。 lombok 本质上就是这样一个程序，它触发生效的具体流程为： 1.javac对源代码进行分析，生成了一棵抽象语法树（AST）2.运行过程中调用实现了“JSR 269 API”的Lombok程序3.此时Lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter和setter方法定义的相应树节点4.javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块） 实现单例注解需要实现的目标 我们想要的注解处理后代码： 1234567891011121314public class RpcComponent&#123; private ClassPathXmlApplicationContext context; public static RpcComponent getInstance() &#123; return RpcComponentHolder.instance; &#125; private static class RpcComponentHolder &#123; private static final RpcComponent instance = new RpcComponent(); &#125;&#125; 在编辑器里实际写的代码： 12345@SingleInstancepublic class RpcComponent&#123; private ClassPathXmlApplicationContext context;&#125; 开始操作 HelloAnnotation 体验编译调用调试创建注解类： 12345678910111213141516package com.sictiy.processor.single;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @author sictiy.xu * @version 2019/10/11 15:17 **/@Target(ElementType.TYPE) // 注解的使用范围，只能用于类@Retention(RetentionPolicy.SOURCE) // 指该注解只存在源代码范围内，编译后不存在public @interface HelloAnnotation&#123;&#125; 创建编译器处理类： 123456789101112131415161718192021222324252627282930313233343536import com.google.auto.service.AutoService;/** * @author sictiy.xu * @version 2020/03/09 11:11 **/@SupportedAnnotationTypes(\"com.sictiy.processor.single.SingleInstance\")@SupportedSourceVersion(SourceVersion.RELEASE_11)@AutoService(Processor.class)public class HelloProcessor extends AbstractProcessor&#123; Messager messager; @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); this.messager = processingEnv.getMessager(); //编译的时候用于输出 &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; Set&lt;? extends Element&gt; set = roundEnv.getElementsAnnotatedWith(HelloAnnotation.class); set.forEach(element -&gt; &#123; note(\"hello world\"); &#125;); return true; &#125; //简单封装的函数 private void note(String message) &#123; this.messager.printMessage(Diagnostic.Kind.NOTE, message); &#125;&#125; auto-service 需要添加maven依赖： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.auto.service&lt;/groupId&gt; &lt;artifactId&gt;auto-service&lt;/artifactId&gt; &lt;version&gt;1.0-rc4&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 使用maven编译打包 在jar里面可以看到这个文件： 文件内容为： 1com.sictiy.processor.single.HelloProcessor 创建另一个项目引用上面第一个项目，新建以下测试类： 12345678910import com.sictiy.processor.single.HelloAnnotation;/** * @author sictiy.xu * @version 2020/03/09 10:52 **/@HelloAnnotationpublic class TestHello&#123;&#125; 在终端第二个项目下运行 mvnDebug clean install 在idea中添加远程调试： 在HelloProcessor中断点后启动调试就可以在idea中断到点了。 在HelloProcessor的基础上修改实现将空类处理成一个单例生成单例主要有下面四个步骤： 1·获取注解对应的类的 AST 树2.添加一个私有的无参数构造器3.添加一个静态内联类，内联类里面要添加一个成员 instance 并完成初始化4.添加一个成员函数，然后 instance 获取ast树获取工具类： 123456789101112131415161718192021@SupportedAnnotationTypes(\"com.sictiy.processor.single.HelloAnnotation\")@SupportedSourceVersion(SourceVersion.RELEASE_11)@AutoService(Processor.class)public class HelloProcessor extends AbstractProcessor&#123; Messager messager; private JavacTrees trees; private TreeMaker treeMaker; private Names names; @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); this.messager = processingEnv.getMessager(); //编译的时候用于输出 this.trees = JavacTrees.instance(processingEnv); //AST 树 Context context = ((JavacProcessingEnvironment) processingEnv).getContext(); this.treeMaker = TreeMaker.instance(context); //封装了定义方法、变量、类等等的方法 this.names = Names.instance(context); //用于创建标识符 &#125; 获取带注解的类的语法树： 123456789101112@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)&#123; // 获取带注解的类的集合 Set&lt;? extends Element&gt; set = roundEnv.getElementsAnnotatedWith(HelloAnnotation.class); set.forEach(element -&gt; &#123; //获取到对应的 AST 树 JCTree jcTree = trees.getTree(element); note(\"hello world\"); &#125;); return true;&#125; 这里有一个问题，在jdk11 版本中移除了bin下面的tools.jar工具包，不再需要手动添加tools.jar的依赖。但是如果直接使用tools包编译时会报错：Error:(20,27) java: 程序包 com.sun.tools.javac.api 不可见 解决方法是在pom.xml中加入： 1234567891011121314&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;configuration&gt; &lt;compilerArgs&gt; &lt;arg&gt;--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED&lt;/arg&gt; &lt;arg&gt;--add-exports=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED&lt;/arg&gt; &lt;arg&gt;--add-exports=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED&lt;/arg&gt; &lt;arg&gt;--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED&lt;/arg&gt; &lt;arg&gt;--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED&lt;/arg&gt; &lt;/compilerArgs&gt; &lt;/configuration&gt;&lt;/plugin&gt; 创建私有构造函数，移除原公共构造函数创建一个私有构造方法： 123456789101112131415// 描述 ，代表方法是私有的JCTree.JCModifiers modifiers = treeMaker.Modifiers(Flags.PRIVATE);// 返回值JCTree.JCBlock block = treeMaker.Block(0L, nil());// 创建这个方法JCTree.JCMethodDecl constructor = treeMaker .MethodDef( modifiers, //修饰符 names.fromString(\"&lt;init&gt;\"), //函数名 null, //方法返回的类型 nil(), //泛型参数 nil(), //参数 nil(), //throw block, //函数代码块，这里是空代码块 null); //默认值 判断方法是否为无参数，公共，且是构造函数： 12345678910111213141516171819202122// 判断是否为构造函数private static boolean isConstructor(JCTree.JCMethodDecl jcMethodDecl)&#123; String name = jcMethodDecl.name.toString(); return \"&lt;init&gt;\".equals(name);&#125;// 判读方法无参数private static boolean isNoArgsMethod(JCTree.JCMethodDecl jcMethodDecl)&#123; List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = jcMethodDecl.getParameters(); return jcVariableDeclList == null || jcVariableDeclList.size() == 0;&#125;// 判断方法是公共的private boolean isPublicMethod(JCTree.JCMethodDecl jcMethodDecl)&#123; JCTree.JCModifiers jcModifiers = jcMethodDecl.getModifiers(); Set&lt;Modifier&gt; modifiers = jcModifiers.getFlags(); return modifiers.contains(Modifier.PUBLIC);&#125; 移除原有的构造函数，添加新构造函数： 12345678910111213//去掉默认的构造函数ListBuffer&lt;JCTree&gt; out = new ListBuffer&lt;&gt;();for (JCTree tree : singletonClass.defs)&#123; if (isPublicDefaultConstructor(tree)) &#123;//是否公有无参数的构造函数 continue; &#125; out.add(tree);&#125;// constructor 就是上面创建的私有构造方法out.add(constructor);singletonClass.defs = out.toList(); 创建内联类分为三步走：1.创建内联类2.创建类型为单例类型的私有静态变量3.将静态变量添加到内联类，将内联类添加到单例类 123456789101112131415161718192021222324252627282930313233343536private JCTree.JCClassDecl createInnerClass(JCTree.JCClassDecl jcClassDecl)&#123; // 创建内联类 JCTree.JCClassDecl innerClass = treeMaker.ClassDef( treeMaker.Modifiers(Flags.PRIVATE | Flags.STATIC), names.fromString(jcClassDecl.name + \"Holder\"), //类名 nil(), //泛型参数 null, //extending nil(), //implementing nil() //类定义的详细语句，包括字段，方法定义等 ); // 给内联类添加一个私有静态的单例的属性 instance // instance 的类型为原静态类 JCTree.JCIdent singletonClassType = treeMaker.Ident(jcClassDecl.name); //获取注解的类型 // instance 的赋值语句 JCTree.JCNewClass newKeyword = treeMaker.NewClass(null, //encl,enclosingExpression lambda 箭头吗？不太清楚 nil(), //参数类型列表 singletonClassType, //待创建对象的类型 nil(), //参数类型 null); //类定义 // instance 是私有，静态，final的 JCTree.JCModifiers fieldMod = treeMaker.Modifiers(Flags.PRIVATE | Flags.STATIC | Flags.FINAL); // 定义这个instance变量 JCTree.JCVariableDecl instanceVar = treeMaker.VarDef( fieldMod, //修饰符 names.fromString(\"instance\"), //变量名 singletonClassType, //类型 newKeyword); //赋值语句 // 将instance 添加到内联函数中 innerClass.defs = innerClass.defs.prepend(instanceVar); // 将内联类添加到原单例类中 jcClassDecl.defs = jcClassDecl.defs.append(innerClass); return innerClass;&#125; 创建获取单例的getInstance方法先看返回语句块怎么构建： 1234567891011121314private JCTree.JCBlock createReturnBlock(JCTree.JCClassDecl innerClass)&#123; // 先拿到内联类的类型 JCTree.JCIdent holderInnerClassType = treeMaker.Ident(innerClass.name); // 再拿到内联类中的静态变量 这个静态变量就是需要返回的值instance JCTree.JCFieldAccess instanceVarAccess = treeMaker.Select(holderInnerClassType, names.fromString(\"instance\")); //创建 return 语句 JCTree.JCReturn returnValue = treeMaker.Return(instanceVarAccess); ListBuffer&lt;JCTree.JCStatement&gt; statements = new ListBuffer&lt;&gt;(); statements.append(returnValue); return treeMaker.Block(0L, statements.toList());&#125; 有了return语句以后就直接构造这个get方法： 123456789101112131415private void createReturnInstance(JCTree.JCClassDecl jcClassDecl, JCTree.JCClassDecl innerClass)&#123; // 方法是静态的公共的 JCTree.JCModifiers fieldMod = treeMaker.Modifiers(Flags.PUBLIC | Flags.STATIC); // 返回类型 是 单例类的类型 JCTree.JCIdent singletonClassType = treeMaker.Ident(jcClassDecl.name); // 构造return 语句块 JCTree.JCBlock body = createReturnBlock(innerClass); //创建方法 JCTree.JCMethodDecl methodDec = treeMaker.MethodDef(fieldMod, this.names.fromString(\"getInstance\"), singletonClassType, nil(), nil(), nil(), body, null); // 将get方法添加的单例类中 jcClassDecl.defs = jcClassDecl.defs.prepend(methodDec);&#125; 将四个步骤组合12345678910111213141516171819202122@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)&#123; var set = roundEnv.getElementsAnnotatedWith(HelloAnnotation.class); set.forEach(element -&gt; &#123; JCTree jcTree = trees.getTree(element); jcTree.accept(new TreeTranslator() &#123; @Override public void visitClassDef(JCTree.JCClassDecl jcClassDecl) &#123; // 修改构造方法 createPrivateConstructor(jcClassDecl); // 添加内联类 JCTree.JCClassDecl innerClass = createInnerClass(jcClassDecl); // 添加getInstance方法 createReturnInstance(jcClassDecl, innerClass); &#125; &#125;); &#125;); return true;&#125; 结果来个简单的示例来试试： 1234@HelloAnnotationpublic class TestHello&#123;&#125; 编译后的.class 用idea打开： 附：以上支持单例注解的实现源代码地址：github lombok idea 插件修改到这里为止给类加上@SingleInstance注解，别的类就可以通过getInstance() 愉快地把他当单例使用了。但问题来了，编译后运行没是啥问题，但是编辑器不认啊，不仅一直先报错标红，而且方法调用的搜索，类Struct里面也找不到这个方法，自动补全什么的更是不可能有了。 所有这部分的任务就是想办法让idea也能知道加注解的意思就是多了个getInstance()方法。这个功能显然需要使用idea插件开发来实现，之前在这里简单了解过一次。这里可以选择重头写一个，想一想这个工作量，emmm… 还好lombok是开源的，在别人的基础上改一改总比重头来简单。 lombok idea 插件github地址：lombok-intellij-plugin fork后修改支持@SingleInstance的源码地址: lombok-intellij-plugin … 未完待续","categories":[{"name":"java","slug":"java","permalink":"https://www.sictiy.cn/hblog/categories/java/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://www.sictiy.cn/hblog/tags/idea/"}]},{"title":"在线记事本折腾小记","slug":"webNotepad","date":"2020-03-08T08:23:49.000Z","updated":"2020-03-08T08:23:49.611Z","comments":true,"path":"2020/03/08/webNotepad/","link":"","permalink":"https://www.sictiy.cn/hblog/2020/03/08/webNotepad/","excerpt":"每次在微信公众号里面看到某个链接想要用电脑打开的时候，总是需要先在电脑登录微信，然后把链接用微信的文件传输助手发送给自己。次数多了总觉得麻烦，于是想找一找有没有一种方便的可以直接通过浏览器直接同步的方式。","text":"每次在微信公众号里面看到某个链接想要用电脑打开的时候，总是需要先在电脑登录微信，然后把链接用微信的文件传输助手发送给自己。次数多了总觉得麻烦，于是想找一找有没有一种方便的可以直接通过浏览器直接同步的方式。 notepa.cc简化版 一番搜索后找到了这个简化版的在线记事本网站，在手机上输入网址后分配了一个后缀，将信息输入后，再电脑上打开同样带后缀的网址，看到的信息同手机上一样，复制粘贴，很ok。地址如下： github地址： demo： 简化版直接根据github上面给的说明，将代码clone到nginx的目录下面，修改nginx的配置即可，非常简单。nginx的配置如下： 1234567891011121314151617location ~* \\.php$ &#123; fastcgi_index index.php; fastcgi_pass 127.0.0.1:9000; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name;&#125;# notes目录进入主页，生成随机码location &#x2F;notes &#123; index index.php;&#125;# 带随机码的将随机码带入参数location ~* ^&#x2F;notes&#x2F;([a-zA-Z0-9_-]+)$ &#123; try_files $uri &#x2F;notes&#x2F;index.php?note&#x3D;$1;&#125; 原版在找到这个网址的帖子里有很多小伙伴都在自己的服务器上部署了，一一点进去方向都一样的，大家都说部署很简单，进github一看就知道，确实简单。但是在最后有一个哥们提问有没有可以实时同步的，不需要手机端编辑后，电脑端需要手动刷新才能看到最新的内容。并贴出了notepad.cc的github地址，说跟这种类似的，但需要文档完备。这个文档太简单，部署麻烦。于是我就进去clone了一份下来，尝试在自己vps上部署，确实很麻烦，一番操作后终于可以顺利通过域名进入主页了，但是同步好像还是有点问题，可能某个nodejs插件没有安装好。最终放弃… 使用WebSocket+editor.md实现实时同步+markdown文档编辑。 WebSocket 随意一搜就可以出现一大堆类似的简单示例，例如：参考链接， 客户端js通过ws协议的链接new一个websocket实例就可以通过这个实例与服务器进行数据交互，服务器通过注解的方式，处理客户端的连接消息的接收回调等，参考文档里可下载示例直接编译运行。 editor.md editor.md是一个开源在线markdown编辑器，地址为:editor.md,。源码目录下的examples下有很多示例，常用的用法基本都可以在这里找到；进入主页后通过 使用示例 就可以看到源码示例中的例子对应的效果。 只需要在页面中加入编辑器的标签就可以将编辑器嵌入页面中： 1&lt;div id=\"test-editor\"&gt;&lt;/div&gt; 链接需要的样式： 12&lt;link rel=\"stylesheet\" href=\"/editormd/css/editormd.css\" /&gt;&lt;link rel=\"stylesheet\" href=\"/editormd/examples/css/style.css\" /&gt; 导入需要的js脚本： 12&lt;script src=\"https://cdn.bootcss.com/jquery/1.11.3/jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"/js/editormd.js\"&gt;&lt;/script&gt; 结合使用 url带tag参数通过目录，或者url参数的形式确定访问的参数，所有同参数的url访问得到相同的文本。具体实现为： 获取url中的参数： 12345678910111213141516171819function getTag() &#123; let tagTemp = window.location.pathname.substr(1); if (tagTemp == null || tagTemp === '')&#123; return getUrlQueryString('tag'); &#125; return tagTemp;&#125;function getUrlQueryString(names, urls) &#123; urls = urls || window.location.href; urls &amp;&amp; urls.indexOf(\"?\") &gt; -1 ? urls = urls .substring(urls.indexOf(\"?\") + 1) : \"\"; let reg = new RegExp(\"(^|&amp;)\" + names + \"=([^&amp;]*)(&amp;|$)\", \"i\"); let r = urls ? urls.match(reg) : window.location.search.substr(1) .match(reg); if (r != null &amp;&amp; r[2] != \"\") return unescape(r[2]); return null;&#125; 如果不带参数随机一个参数，重定向到新的url： 1234567let tag = getTag();if (tag == null)&#123; tag = randomString(5); window.location.href = \"?tag=\"+tag; exit(0);&#125; 服务端读取参数，相同参数的客户端连接放入同一组： 123456789@OnOpenpublic void onOpen(@PathParam(\"tag\") String tag, Session session)&#123; this.session = session; this.tag = tag; var socketTestSet = groupSockets.computeIfAbsent(tag, k -&gt; new CopyOnWriteArraySet&lt;&gt;()); socketTestSet.add(this); //加入set中 LogUtil.info(\"new connect, tag:\" + tag + \", current online:\" + getOnlineCount(tag));&#125; 服务端通过tag处理文本内容的同步与存储服务端内存临时存储文本内容： 1private static Map&lt;String, StringBuilder&gt; groupString = new ConcurrentHashMap&lt;&gt;(); 最终将文本内容存储在文件中： 12345678910111213141516171819202122232425public static boolean writeFileString(String fileName, String content, boolean isAppend)&#123; try &#123; File file = new File(fileName); if (!file.getParentFile().exists()) &#123; if(!file.getParentFile().mkdirs()) &#123; return false; &#125; &#125; RandomAccessFile accessFile = new RandomAccessFile(file, \"rw\"); accessFile.seek(isAppend ? file.length() : 0); accessFile.write(content.getBytes(StandardCharsets.UTF_8)); accessFile.close(); LogUtil.info(\"write to file: \" + fileName); return true; &#125; catch (IOException e) &#123; LogUtil.exception(e); &#125; return false;&#125; 服务端与各客户端同步文本客户端加载完且websocket连接完后向服务端请求已有的文本内容： 1234if (hasInit &lt; 0)&#123; return&#125;sendJson(1, ''); 客户端editor.md 组件回调文本有改变时 将文本内容同步给服务器： 12345678onchange : function () &#123; if (isNew) &#123; setMessageLog('Saving...'); sendMessage(this.getValue()) &#125; isNew = true;&#125; 这里有个问题，当editor.md 组件设置为不实时预览时，onchange() 函数不会调用；需要找到editor.md源码里触发onchange()的地方，将onchange函数的调用，放到判断预览的外面： 1234567891011121314151617// if(settings.watch || (!settings.watch &amp;&amp; state.preview))// &#123;// ...// if (state.loaded) // &#123;// $.proxy(settings.onchange, this)();// &#125;// &#125;;// 修改为if(settings.watch || (!settings.watch &amp;&amp; state.preview))&#123; // ...&#125;;if(state.loaded)&#123; $.proxy(settings.onchange, this)();&#125; 服务端接收到最新的文本后，将文本转发给别的同tag参数的客户端，并缓存： 123456789101112131415161718192021222324252627282930313233343536//群发消息var webSocketSet = groupSockets.getOrDefault(tag, new HashSet&lt;&gt;());for (NotepadSocket item : webSocketSet)&#123; try &#123; if (item == this) &#123; item.sendMessage(message, SELF); &#125; else &#123; item.sendMessage(message, OTHERS); &#125; &#125; catch (IOException e) &#123; LogUtil.exception(e); &#125;&#125;// 保存消息if (groupString.containsKey(tag))&#123; // 假设是追加 // groupString.get(tag).append(message); groupString.put(tag, new StringBuilder(message));&#125;else&#123; groupString.put(tag, new StringBuilder(message));&#125;// 需要修改为定时保存，而不是每一次收到更新就保存到文件if(!writeFileString(getMdPath() + tag, message, false))&#123; LogUtil.error(\"write to file failed! tag:&#123;&#125;, message:&#123;&#125;, path:&#123;&#125;\", tag, message, getMdPath());&#125; 完成 修改后的代码：webNotepad 部署后的预览地址：notepad.sictiy.cn","categories":[{"name":"java","slug":"java","permalink":"https://www.sictiy.cn/hblog/categories/java/"}],"tags":[]},{"title":"字符串匹配","slug":"charMatch","date":"2020-01-15T04:46:18.000Z","updated":"2020-01-17T15:59:07.460Z","comments":true,"path":"2020/01/15/charMatch/","link":"","permalink":"https://www.sictiy.cn/hblog/2020/01/15/charMatch/","excerpt":"字符串匹配是一个各大学教科书上经常出现的经典问题。","text":"字符串匹配是一个各大学教科书上经常出现的经典问题。 问题描述文本input为一个一定长度的字符串，文本pattern为一个长度小于input的字符串。字符串里面的所有字符都是26个小写字母，求pattern在input中第一次出现的问题，如果没有出现过返回-1。 解法暴力法最容易想到的就是直接从左往右遍历所有字符，没什么好说的，实现代码如下： 123456789101112131415161718// BF算法func matchBF(bInput []byte, bPattern []byte) int &#123; lenP := len(bPattern) lenI := len(bInput) for i:= 0; i &lt;= lenI - lenP; i++ &#123; match := true for j := 0; j &lt; lenP; j++ &#123; if bInput[i + j] != bPattern[j] &#123; match = false break &#125; &#125; if match &#123; return i &#125; &#125; return -1&#125; KR算法暴击法虽然简单，但主串遍历一遍n次，每一次需要遍历一遍匹配串判断当前位置是否匹配，最差需要n*m次计算才能遍历完，计算量太大。KR算法在暴力法的基础上，对每一个位置上的遍历判断改为计算匹配串与相应子串的hash值，如果hash值相等，再从左到右遍历。假设hash值的计算为 a=1，b=2，c=3 对字符串的值求和得到hash，那么计算如图： 显然该位置主串的子串与匹配串不相同，但hash相同不一定绝对匹配，比如abc与acb 计算的hash相等，但字符串不匹配，所以hash相等时还需要逐字符判断一遍。另外，hash算法的冲突率对整个算法的影响很大，冲突率越高，hash相等时字符串不匹配的几率越高，计算量越大，一个简单的hash算法如下： 12345678func calHashCode(input []byte) int &#123; result := 0 for _, i := range input &#123; result += int(i) result *= defaultPower &#125; return result&#125; 这样就ok了吗？并不，因为一般hash的计算同样需要遍历一遍字符串，虽然匹配串是固定的不需要重新计算，但是每个位置对于的子串都不同，如果每个位置都要遍历一遍子串来计算hash，那计算量和暴力法也没什么差别甚至更高。所以在这里需要利用部分字符重叠这个特性，在上图中，第0个位置子串为abc 第1个位置子串为bcd 其中bc是重叠的，计算hash的时候只需要把a去掉，加上d就可以了。具体的做法如以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142var defaultPower = 26func matchKR(bInput []byte, bPattern []byte) int &#123; lenP := len(bPattern) lenI := len(bInput) hashCodeP := calHashCode(bPattern) hashCodeI := calHashCode(bInput[0:lenP]) // 计算hashcode时每次减去的基数 subPower := calPower(defaultPower, lenP + 1) for i:= 0; i &lt;= lenI - lenP; i++ &#123; if hashCodeI == hashCodeP &#123; // 粗略匹配 match := true for j := 0; j &lt; lenP ; j++ &#123; if bInput[i + j] != bPattern[j] &#123; match = false break &#125; &#125; // 真的匹配 if match &#123; return i &#125; &#125; if i + lenP &gt;= lenI &#123; return -1 &#125; // 不匹配时 更新子串的hashCode hashCodeI += int(bInput[i +lenP]) hashCodeI *= defaultPower hashCodeI -= subPower * int(bInput[i]) &#125; return -1&#125;func calPower(a int, b int) int &#123; result := 1 for i := 0; i&lt; b; i++ &#123; result *= a &#125; return result&#125; BM(Boyer-Moore)算法上述两个算法每次匹配串都只往右移动一个位置，这样显然太慢了些，很多时候是可以一次移动多个位置的。 BM算法就是这样一个算法，其思想是如果子串中有模式串中不存在的字符，那肯定不匹配，可以往后多移动几步。为了更快发现不存在的字符，并且尽量往后多移动几步，BM算法选择从后往前逐字判断。 如图，先判断c与c相等，再往前，b和c不相等。因为匹配串中不含b，所以匹配串可以直接往后移动两步使匹配串跳过b。 算法细则坏字符规则坏字符只是指子串中从后往前遇到的第一个不匹配的字符，在上述的例子中，b就是这个坏字符。坏字符规则是指，当子串中存在坏字符时，匹配串向右移动使坏字符与匹配串中的相同字符对应，如果不存在则使匹配串移动到坏字符后一个位置。如图： 因为匹配串是固定的，每一个字符在匹配串的最后一个位置也是固定的，所以可以提前预处理匹配串，找出匹配串中每一个字符在串中的最后一个位置，组成map，当寻找坏字符在匹配串的位置时只需要去map中寻找，不再需要重复遍历匹配串。代码如下： 123456789101112131415//坏字符预处理//O(n)func generalBadCharMap(bPattern []byte, bInput []byte) map[byte]int &#123; lenP := len(bPattern) bCharArray := make(map[byte]int) // 这里将主串中所有出现过的字符对应的value提前置为-1，代表坏字符移动到-1的位置 for _, i := range bInput &#123; bCharArray[i] = -1 &#125; // key字符 在pattern里的最后一个位置 for i := 0; i &lt; lenP; i++&#123; bCharArray[bPattern[i]] = i &#125; return bCharArray&#125; 好后缀规则好后缀是指坏字符后面已经能够匹配的字符后缀，如上图中的好后缀为 da 和 a。好后缀规则是指，当子串存在好后缀时，匹配串向右移动使长度最长的好后缀与匹配串中的相同子串对应，如果不存在相同的子串，则在其他好后缀中寻找与匹配串中相同前缀匹配的最长者相对应，如果依然不存在，将好后缀移动到匹配串的最前面。所以好后缀规则存在三种情况： 最长好后缀在匹配串中存在相同子串 最长好后缀不存在相同子串，但是好后缀中存在与匹配串中相同的前缀 都不存在 好后缀同样可以提前预处理，一个比较暴力的处理方法为： 123456789101112131415161718192021222324252627282930313233343536373839404142//好后缀预处理//返回 map key深度好后缀最后个子串的位置value//暴力法func generalGoodSuffix(bPattern []byte) map[int]int &#123; lenP := len(bPattern) // suffix中保存 key深度的好后缀在匹配串中最后一个相同子串的位置，如果不存在 value为-1 suffix := make(map[int]int) // prefix中保存 key深度的好后缀是否存在相同的前缀，如果存在value为1 否则为-1 prefix := make(map[int]int) // 初始化所有深度 value值 for i := 1; i &lt; lenP ; i++ &#123; suffix[i] = -1 prefix[i] = -1 &#125; // i 从0往右遍历的深度 // 找到所有深度为i的好后缀再最后一次出现的位置 for i := 0; i &lt; lenP - 1; i++ &#123; j := i // 深度为i的串最右边开始往左判断 for j &gt;= 0 &amp;&amp; bPattern[j] == bPattern[lenP - 1 - i + j] &#123; j-- suffix[i - j] = j + 1 // 最后一个深度为i - j 的串的位置 &#125; if j == 0 &#123; prefix[i] = 1 &#125; &#125; // 处理前缀 当深度为i的好后缀 在模式串前没有出现过第二次时 找到这个好后缀的最长前缀子串 for i := 1; i &lt; lenP; i++ &#123; // 当前深度没有匹配的串 if suffix[i] == -1 &#123; for j := i - 1; j &gt; 0; j-- &#123; // 找到最长前缀子串 if prefix[j] == 1 &#123; // 将最长子串移动到最前面 相当于 当前深度串移动到最前面往前i - j个位置 当i=j时理论应该直接移动到0位置 suffix[i] = j - i break &#125; &#125; &#125; &#125; return suffix&#125; 主规则得到处理后的好后缀与坏字符map后，对于每一个不匹配的位置，都可以通过好后缀规则与坏字符规则计算一个移动步数，取两者较大者对匹配串进行移动，具体实现如下： 123456789101112131415161718192021222324252627282930313233// BM算法func matchBM(bInput []byte, bPattern []byte) int &#123; i := 0 // 输入串与匹配串偏移量 var j int // 输入串与匹配串匹配的第一个字符 goodSuffix := generalGoodSuffix(bPattern) badChar := generalBadCharMap(bPattern, bInput) lenI := len(bInput) lenP := len(bPattern) for i &lt;= lenI -lenP &#123; for j = lenP - 1; j &gt;= 0; j-- &#123; // 第一个坏字符 if bInput[i + j] != bPattern[j] &#123; break &#125; &#125; // 成功 if j &lt; 0 &#123; return i &#125; badMove := j - badChar[bInput[i + j]] goodMove := 0 // 不是最后一个字符 有好后缀 if j &lt; lenP -1 &#123; goodMove = j + 1 - goodSuffix[lenP - j] &#125; if badMove &gt; goodMove&#123; i += badMove &#125; else &#123; i += goodMove &#125; &#125; return -1&#125; KMP算法next数组KMP算法同样尽量使匹配串更快地往右移动，不过利用的是匹配串中的另一个信息。这个信息为：对于每匹配串 t 的每个元素 t j，都存在一个实数 k ，使得匹配串 t 开头的 k 个字符（t 0 t 1…t k-1）依次与 t j 前面的 k（t j-k t j-k+1…t j-1，这里第一个字符 t j-k 最多从 t 1 开始，所以 k &lt; j）个字符相同。如果这样的 k 有多个，则取最大的一个。匹配串中每一个位置j都有这样一个k，通过next数组表示，即 next[j] = max{k}这个信息是什么意思呢？可以通过下图来理解： 对于j = 5 存在这样一个k = 2, 使 p[j]前面的k个字符，与匹配串开头的k个字符相同，则next[5] = 2。 因为这个信息是每个匹配串都存在的信息，我们可以拿匹配串进行预处理，得到长度与匹配串长度相同的next数组，代码如下： 12345678910111213141516171819202122232425// 预处理nextfunc generalNextMap(bPattern []byte) map[int]int &#123; next := make(map[int]int) j, k := 0, -1 next[j] = k lenP := len(bPattern) for j &lt; lenP - 1 &#123; // k == -1 时 第一个字符都不匹配，往后移 // bk == bj 时 匹配 继续往后寻找 if k == -1 || bPattern[k] == bPattern[j] &#123; k++ j++ // 优化后的代码，原算法不判断==，直接赋值k if bPattern[k] == bPattern[j] &#123; next[j] = next[k] &#125; else &#123; next[j] = k &#125; &#125; else &#123; // bk != bj 时 因为k前面的n个字符 与j前面的n个字符匹配 那么将k 替换为next[k]以后 则j前面next[k]个字符同样与next[k]前面next[k]个字符匹配 达到等价回退的目的 k = next[k] &#125; &#125; return next&#125; 预处理next的遍历过程分三种情况： k == -1，p[j] 前面0个字符与前缀相同，这时将k与j都加一，继续往后一位判断。 p[j] == p[k] 此时，开头k个字符与p[j] 相同，那么开头k+1个字符与p[j+1]前面的k+1个字符相同。 p[j] != p[k] 两个字符不相同时，原算法直接令 k = next[k], 这个该怎么理解呢？当两个字符不匹配时，显然是k太大了，需要缩短开头的k个字符的长度，使p[j]的前k`个字符与开头的k`个字符相同，因为p[j]的前k个字符与开头的k个字符相同，所以p[j]前面的k个字符 与 p[k] 前面的k个字符相同，而p[k]前面的k`个字符与开头k`个字符相同等价于p[j]前面的k`个字符与开头的k`个字符相同。前面已经求得next[k] = k`,所以令 k = k` = next[k] 主逻辑两个指针IJ分别代表在主串与匹配串中的位置，IJ从左往右遍历，当IJ所指的字符相等时一起往后移动。当两个字符不相等时，如下图I = 3， J = 3，此时p[j]前面的k = 1个字符与匹配串开头的k 个字符相同，所以I不动，将J移动到K的位置，使两个a对应。 具体代码如下: 1234567891011121314151617181920// KMP 算法func matchKMP(bInput []byte, bPattern []byte) int &#123; next := generalNextMap(bPattern) i, j := 0, 0 lenI := len(bInput) lenP := len(bPattern) for i &lt; lenI &amp;&amp; j &lt; lenP &#123; if j == -1 || bInput[i] == bPattern[j] &#123; i++ j++ &#125; else &#123; j = next[j] &#125; &#125; // 遍历完成 如果j先遍历完则存在匹配 if j &gt;= lenP &#123; return i - lenP &#125; return -1&#125; Sunday算法Sunday算法与BM算法的坏字符规则相似，BM算法移动到坏字符与匹配串中相同的字符相对应，而Sunday算法找到的不是坏字符，而是子串最后一个字符的下一个字符，该字符的移动规则与BM算法坏字符的移动规则一致， 如下图。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536// Sunday算法func matchSunday(bInput []byte, bPattern []byte) int &#123; offset := getOffsetMap(bPattern) lenI := len(bInput) lenP := len(bPattern) i, j := 0, 0 for i &lt;= lenI - lenP &#123; j = 0 for bInput[i + j] == bPattern[j] &#123; j++ if j &gt;= lenP &#123; return i &#125; &#125; if i + lenP &gt;= lenI &#123; return -1 &#125; move, ok := offset[bInput[i + lenP]] if ok &#123; i += move &#125; else &#123; i += lenP + 1 &#125; &#125; return -1&#125;// offestmap 存字符到匹配串最后面一个字符的距离func getOffsetMap(bPattern []byte) map[byte]int &#123; offset := make(map[byte]int) lenP := len(bPattern) for i, c := range bPattern&#123; offset[c] = lenP - i &#125; return offset&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.sictiy.cn/hblog/categories/algorithm/"}],"tags":[]},{"title":"Java Stream 理解","slug":"stream","date":"2020-01-14T00:34:59.000Z","updated":"2020-01-16T03:28:47.645Z","comments":true,"path":"2020/01/14/stream/","link":"","permalink":"https://www.sictiy.cn/hblog/2020/01/14/stream/","excerpt":"","text":"概述什么叫流Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作，或者大批量数据操作 。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性. 与直接对集合类进行连续的一系列操作不同，使用流并非对集合类的所有元素进行一个操作之后得到中间集合再进行下一步的操作，而是针对流中的每一个元素按流的方向依次执行所有操作，不存在中间集合，所有的这些流式操作都在终端操作(如图中的ForEach)执行时才开始执行。 流的特点 流管道由数据源、中间操作、终端操作组成。终端操作可以没有也可以有多个，数据源和终端操作只有一个。 流不存储数据、流可能是无界的、流是可以被消耗的。流通过数据源不断生成单个元素，当整个流执行完终端操作之后流被标记成已消耗，无法再次执行终段操作。 流的操作基本都是函数式接口的实例，中间操作的函数式操作是延迟执行的。 流分为顺序执行和并行执行两种方式。并行执行依赖数据源Spliterator体验的并行遍历机制。 预备SpliteratorSpliterator为Iterator的并行版本，提供对集合数据的并行遍历能力。 这里主要依赖三个方法: tryAdvance, forEachRemaining, trySplit。 tryAdvance 生成一个元素并对该元素执行传入的Consumer操作，返回的boolean值代表是否还可以继续生成下一个元素 forEachRemaining 顾名思义该方法为对所有剩余生成的元素执行传入到的Consumer操作，该方法的默认实现为循环调用tryAdvance方法，直到其返回值为false。 trySplit 该方法用于实现并行遍历。调用该方法后该Spliterator会拆分另一个Spliterator并返回，两个Spliterator可在两个线程中进行并行遍历。 FunctorFunctor函子本是范畴论中的一个概念，指范畴间的一类映射。在函数式编程里，主要指对普通对象的封装，相对普通函数对简单对象进行操作映射，函子函数对高阶对象进行操作映射。 可以通过一段示例代码进行理解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 函子 * * @author sictiy.xu * @version 2020/01/06 10:03 **/public interface Functor&lt;T, F extends Functor&lt;?, ?&gt;&gt;&#123; &lt;R&gt; F map(Function&lt;T, R&gt; f);&#125;/** * 通用函子 * * @author sictiy.xu * @version 2020/01/06 10:05 **/public class CommonFunctor&lt;T&gt; implements Functor&lt;T, CommonFunctor&lt;?&gt;&gt;&#123; private T value; public CommonFunctor(T value) &#123; this.value = value; &#125; @Override public &lt;R&gt; CommonFunctor&lt;R&gt; map(Function&lt;T, R&gt; f) &#123; final R result = f.apply(value); return new CommonFunctor&lt;&gt;(result); &#125; public T getValue() &#123; return value; &#125; public static void main(String[] args) &#123; var functor = new CommonFunctor&lt;&gt;(10); LogUtil.info(\"&#123;&#125;\", functor.map(a -&gt; a + 1).map(a -&gt; a * 10).getValue()); &#125;&#125; 函子接口Functor定义函子函数map，所有的函子都需要实现该接口。在实现类中，函子对象封装了普通对象T，而函子函数接收一个Function操作，该Function操作对普通对象T进行处理，结果为普通对象R。函子函数解析函子中封装的普通对象执行Function操作后将结果封装成新的函子对象。由于函子对象的map方法返回的是一个新的函子对象，所以可以连续的调用链式调用map方法直到调用getValue方法解析最后一个函子对象所封装的普通对象。该Functor虽然形式上与Stream一样，可以链式调用对象的方法，但是每一步调用依然是即时操作的，那如果对传入的操作并不马上操作，而是将传入的函数式接口通过对象属性或者保存在抽象方法的实现中，然后在最后需要获得结果的时候再统一处理所有的操作，是不是就是Stream实现的基本思想呢？ Stream基本用法 Stream中的操作可以分为两大类：中间操作与结束操作，中间操作只是对操作进行了记录，只有结束操作才会触发实际的计算（即惰性求值），这也是Stream在迭代大集合时高效的原因之一。中间操作又可以分为无状态（Stateless）操作与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响；后者是指该操作只有拿到所有元素之后才能继续下去。结束操作又可以分为短路与非短路操作，这个应该很好理解，前者是指遇到某些符合条件的元素就可以得到最终结果；而后者是指必须处理所有元素才能得到最终结果。 流程原理一个小栗子1234567891011private static void testStream()&#123; String[] words = &#123;\"hello\", \"my\", \"world\"&#125;; var strStream = Arrays.stream(words); var tempStream = strStream.filter(word -&gt; word.length() &gt; 3) .map(word -&gt; word.split(\"\")) .flatMap(Arrays::stream) .map(String::toUpperCase); var result = tempStream.reduce((a, b) -&gt; a + \",\" + b); LogUtil.info(result.orElse(\"null\"));&#125; 结果为： 1[2020-01-15 10:49:56:721] [INFO ] com.sictiy.jserver.Test.testStream(Test.java:44) H,E,L,L,O,W,O,R,L,D 先看一下通过Arrays.stream方法创建的Stream是什么样的： 首先返回的strSteam是个***PipeLine$Head的实例，显然这是一个Stream的实现类，该类有一个属性sourceStage指向自己，有一个属性sourceSpliterator是根据传入的数组生成的一个ArraySpliterator实例。 按Functor的思想，函子函数接收一个函数式接口应该返回另一个函子对象，那stream是怎么样的呢？再看一下filter函数里面是怎么实现的： filter方法返回了一个叫做StatelessOp的Stream接口的实现，但在方法体内除了对传入的predicate进行空指针判断以外并没有进行其他的处理。返回的StatelessOp类重写了opWarpSink方法，而onWarpSink方法返回一个Sink接口，该Sink接口实现了accept方法，接收一个对象，如果满足predicate，则执行downstream的accept方法，这个sink可以理解为前一个操作调用该sink的accept接口，如果入参满足predicate，那继续调用下一个操作。我们已经知道了传入的predicate存放到的位置，但依然不知道这个sink什么时候使用，怎么使用。 知道了增加一个中间操作做了什么以后，再看一下调用了一堆中间操作后返回到的tempStream是什么样的： 该Stream的结构很清晰，就是一个双向链表结构，所有的sourceStage指向最先生成的那个头，previousStage从最后生成的Stream一直往前指向头，而nextStage则从头往后一直指向最后一个Stream，结构是这样的： 到目前为止通过这个栗子把从创建的Head，到调用若干次中间操作后返回的StatelessOp的流程、以及最后返回的实例的整体结构都了解了一遍。 Stream族谱 BaseStream类是所有Stream的基本接口，定义了是否并行，数据源，关闭回调等基本方法，Stream流继承了AutoCloseable接口不需要手动关闭。 BaseStream有四个分支，其中Stream处理的元素为引用类型而另外三个分别处理int，lang，double三种基本类型的数据。 AbstractPipeLine 定义了Stream双向链表的管道结构。 PipeLineHelper 为管道辅助类，主要定义了一些终端操作中与计算相关的一些方法，比如WarpSink、copyInto等。 ***PipeLine里定义了Head StatelessOp StatefulOp 三种具体的实现类，初始的Stream为Head，中间操作后生成的根据操作的不同分为Stateless和StatefulOp 终端操作流程回到之前的小栗子，看双向链表结构的Pipeline是怎么通过warpSink组合不同的操作再讲操作运用到产生元素的Spliterator的。 终端操作reduce调用了***PipeLine的evaluate方法，传入了一个ReduceOps的实例。ReduceOps代表了reduce这种终端操作，是TerminalOp接口的一个实现。 在evaluate方法里根据条件是否并行分别调用了 TerminalOp的并行计算与顺序计算方法，传入参数为类型为pipelinehelper的this本身，和产生元素的Spliterator。 以顺序执行为例，计算过程分为makeSink warpSink 和 copyInto 三个过程。 makeSink由终端操作实例提供，生成第一个sink操作，代表整个操作流中的最后一个sink。 warpSink 由 PipelineHelper提供，根据管道结构从最后一个中间操作开始不断往前调用***Pipeline的opWarpSink方法，将所有中间操作和终端操作进行组合，返回一个组合了所有操作的最终Sink。 copyInto 同样由PipelineHelper提供，用于将生成的最终Sink应用于传入的Spliterator，使每一个元素依次执行这个Sink方法。 SinkSink是组合流管道流式操作的媒介，继承至Comsummer接口，可以对传入的元素进行一定的处理，Sink接口主要有以下方法： Sink有两种状态，初始状态和激活状态begin后进入激活状态，end后重新进入初始状态，accept方法只有在激活状态才能使用。Sink通过终端操作往前封装，后一个sink传入前一个Sink，保存在downStream属性中，每一个PipeLine 通过实现onWarpSink方法实现当前操作与下一步操作的封装，如下图，filter方法返回的Pipeline实现的opWarpSink方法返回当前操作的Sink，该Sink接收一个对象，如果对象满足predicate则将对象传递给downStream继续处理下一个操作： Stream的工作流程总览 另一个栗子12345678910111213private static void testStream()&#123; String[] words = &#123;\"hello\", \"my\", \"world\"&#125;; var strStream = Arrays.stream(words); var tempStream = strStream.filter(word -&gt; word.length() &gt; 3) .map(word -&gt; word.split(\"\")) .flatMap(Arrays::stream) .distinct() .map(String::toUpperCase) .sorted(); var result = tempStream.reduce((a, b) -&gt; a + \",\" + b); LogUtil.info(result.orElse(\"null\"));&#125; 输出结果： 1[2020-01-15 14:55:01:444] [INFO ] com.sictiy.jserver.Test.testStream(Test.java:46) D,E,H,L,O,R,W 有状态操作当栗子里面加入了sorted和distinct两个中间操作后，原来的逻辑好像有了点问题。按原来的流程，所有操作组合成一个流式的Sink后，Spliterator生成序列的元素，依次通过Sink处理，各元素之间相互不影响。但是当操作中出现有状态操作时，比如sorted需要依赖各个元素之间的大小关系，显然无法生成一个元素处理一个元素，那这种有状态操作又是如何处理的呢？通过观察第二个栗子的reduce执行步骤发现，整体流程依然没有变化，变化的只是双向链表的单个操作节点由StateleOp替换为了StatefulOp的实现类，比如sorted方法返回的是实现类SortedOps。我们已经知道不同操作节点之间的操作斜街是通过opWarpSink实现的，那有状态操作与无状态操作最大的不同肯定就在于opWarpSink了，来看一下该方法返回的是什么样的Sink： 123456789101112131415161718192021222324252627282930313233343536373839/** * &#123;@link Sink&#125; for implementing sort on reference streams. */private static final class RefSortingSink&lt;T&gt; extends AbstractRefSortingSink&lt;T&gt; &#123; private ArrayList&lt;T&gt; list; RefSortingSink(Sink&lt;? super T&gt; sink, Comparator&lt;? super T&gt; comparator) &#123; super(sink, comparator); &#125; @Override public void begin(long size) &#123; if (size &gt;= Nodes.MAX_ARRAY_SIZE) throw new IllegalArgumentException(Nodes.BAD_SIZE); list = (size &gt;= 0) ? new ArrayList&lt;&gt;((int) size) : new ArrayList&lt;&gt;(); &#125; @Override public void end() &#123; list.sort(comparator); downstream.begin(list.size()); if (!cancellationRequestedCalled) &#123; list.forEach(downstream::accept); &#125; else &#123; for (T t : list) &#123; if (downstream.cancellationRequested()) break; downstream.accept(t); &#125; &#125; downstream.end(); list = null; &#125; @Override public void accept(T t) &#123; list.add(t); &#125;&#125; 该Sink的accept方法接收一个元素后并没有将这个元素继续往下传递，而是存放在list当中，当所有元素都生成完之后，copyInto方法中调用end方法，当end传递到sorted操作这一层的时候，先对list进行排序，然后依次对其中的元素调用downstream的accept方法向下传递，所有元素都处理完之后，再传递end方法的调用。相当于当元素流在操作管道中传递的时候，在这一步截断了，对所有元素排序后，继续依次往后传递。既然排序操作是这样的，那去重操作呢，再看一下： 未排序的stream： 1234567891011121314151617181920212223return new Sink.ChainedReference&lt;T, T&gt;(sink) &#123; Set&lt;T&gt; seen; @Override public void begin(long size) &#123; seen = new HashSet&lt;&gt;(); downstream.begin(-1); &#125; @Override public void end() &#123; seen = null; downstream.end(); &#125; @Override public void accept(T t) &#123; if (!seen.contains(t)) &#123; seen.add(t); downstream.accept(t); &#125; &#125;&#125;; 已排序的stream： 123456789101112131415161718192021222324252627282930return new Sink.ChainedReference&lt;T, T&gt;(sink) &#123; boolean seenNull; T lastSeen; @Override public void begin(long size) &#123; seenNull = false; lastSeen = null; downstream.begin(-1); &#125; @Override public void end() &#123; seenNull = false; lastSeen = null; downstream.end(); &#125; @Override public void accept(T t) &#123; if (t == null) &#123; if (!seenNull) &#123; seenNull = true; downstream.accept(lastSeen = null); &#125; &#125; else if (lastSeen == null || !t.equals(lastSeen)) &#123; downstream.accept(lastSeen = t); &#125; &#125;&#125;; 显然该Sink就可以达到去重的目的，当Stream是已排序的时，重复元素只可能连续出现，只需要与上一次传入的元素对比，如果相同则已处理过重复元素直接丢弃；当Stream时未排序的时，将已处理的元素记录在set中，当下次接收到相同元素时丢弃。所谓有状态，即时在当前操作处理一个元素之后需要记录某些信息，决定后面的元素的操作，而这种机制就是依靠Sink来实现的，不同的操作实现不同的opWarpSink，返回不同的Sink，Sink中可以记录某些信息来实现有状态。","categories":[{"name":"java","slug":"java","permalink":"https://www.sictiy.cn/hblog/categories/java/"}],"tags":[]},{"title":"炮弹挖坑问题","slug":"dig","date":"2019-09-20T01:48:27.000Z","updated":"2020-01-16T03:28:47.644Z","comments":true,"path":"2019/09/20/dig/","link":"","permalink":"https://www.sictiy.cn/hblog/2019/09/20/dig/","excerpt":"","text":"炮弹挖坑流程 炮弹打在地图上，产生一定形状的弹坑。 地图和弹坑形状都为二进制数据，一个byte共8位，每一位表示一个像素点，代表改像素点是否为空点。 整个地图的数据为一个byte数组，xy坐标系下x0,y0 点的数据，保存在byte数组的第 y0 * wight + x / 8 个byte中，具体为该byte的第 x % 8 位。其中wight为整个地图一横排的所有点的byte的数量。 炮弹打在地图上，在击中点生成一个弹坑数据，弹坑数据与地图数据在地图坐标系下求交集，再在地图数据中，减去交集中的实心点，就可以得到挖坑后的地图数据。 地图数据减去弹坑数据流程 按行移除 按y 遍历所有行，每一行取出地图数据与弹坑数据，每一行计算交集矩形宽度范围内的像素点。 根据地图数据起始点的x值，计算该byte需要计算的位数。 根据弹坑数据起始点的x值，计算该byte拥有的位数，对两个byte进行左右移动，使起始位的偏移值相同。 如果弹坑数据该byte拥有的位数不够，则取下一个byte的前几位，使弹坑的位数等于需要计算的位数。 然后将弹坑byte取反，并与上地图byte求出该地图byte计算后的byte值 按像素移除 按x，按y，遍历所有xy像素点，如果地图可挖，弹坑为实心，则把改地图像素置为空 问题 偶尔会出现弹坑左边边界处有多挖的情况。也就是说取弹坑byte的时候，会出现多余的1。 解决 断点跟踪后发现，-32 右移 7位后变成了-1,-32的二进制表示为：11100000, -1二进制表示为11111111。 查找资料后发现&gt;&gt; 右移操作为有符号右移，即右移时会保持符号不变，所以左边会补1。而&gt;&gt;&gt;为 无符号右移。 尝试使用&gt;&gt;&gt; 发现和原来结果一样 继续查资料 发现&gt;&gt;&gt; 虽然是无符号的右移，但是byte类型的进行右移会默认转为32位int类型，然后进行无符号右移，再转换为byte。 因为会转换为int类型，所以我们可以将原byte &amp; 0xff 把int的前24位置0，再进行右移，然后转为byte。完美解决","categories":[],"tags":[]},{"title":"服务器热更","slug":"服务器热更","date":"2019-05-20T00:50:22.000Z","updated":"2020-01-16T03:28:47.645Z","comments":true,"path":"2019/05/20/服务器热更/","link":"","permalink":"https://www.sictiy.cn/hblog/2019/05/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%83%AD%E6%9B%B4/","excerpt":"","text":"如何确定需要更新的表\\class文件 cmd命令传入 放在指定的文件夹 代码热更,热替换 classReloader premain可以获取instrumentation 编译成jar,需要一些属性 启动参数：-javaagent 需要再启动的时候就开启代理 agentmain也可以拿到instrumentation 编译成jar updatemain进程 通过pid拿到游戏服的vm vm.loadAgent() 调用loadAgent.jar的loadAgent函数 不需要在启动的时候开启代理 instrumentation.redifineClass替换class文件 ClassFileTransformer 数据热更 需要reload的方法注册在map中 传入类名，在map中找到对应的reload方法，invoke","categories":[{"name":"java","slug":"java","permalink":"https://www.sictiy.cn/hblog/categories/java/"}],"tags":[]},{"title":"Spider存储引擎尝试","slug":"spider","date":"2019-05-15T22:33:00.000Z","updated":"2020-01-16T03:28:47.644Z","comments":true,"path":"2019/05/16/spider/","link":"","permalink":"https://www.sictiy.cn/hblog/2019/05/16/spider/","excerpt":"","text":"安装升级mariadb 卸载旧的 123yum remove mariadbrm -f /etc/my.cnfrm -rf /var/lib/mysql/ 添加源 1vim /etc/yum.repos.d/Mariadb.repo 添加： 12345[mariadb]name = MariaDBbaseurl = https://mirrors.ustc.edu.cn/mariadb/yum/10.2/centos7-amd64gpgkey=https://mirrors.ustc.edu.cn/mariadb/yum/RPM-GPG-KEY-MariaDBgpgcheck=1 12yum clean allyum makecache all 安装 123yum install MariaDB-server MariaDB-client -ysystemctl start mariadb.servicesystemctl enable mariadb.service 出现下面的无法启动的问题： 1ExecStart=/usr/sbin/mysqld $MYSQLD_OPTS $_WSREP_NEW_CLUSTER $_WSREP_START_POSITION (code=exited, status=1/FAILURE) 12mysql_install_dbchmod -R 777 /var 初始化 12/usr/bin/mysql_secure_installation(enter: yynyy) 安装spider 安装spider 12// install_spider.sql 在share/下mysql -uroot -p &lt; install_spider.sql 改命令实际创建了表 123456spider_link_failed_logspider_link_mon_serversspider_tablesspider_xaspider_xa_failed_logspider_xa_member 查看是否安装成功 1select * from infomation_scheme.engines 使用准备 准备实际存储数据的数据库 12345678910&#x2F;&#x2F; 在从数据库添加主数据库的访问权限grant all on *.* to root@&#39;104.198.*.*&#39; identified by &#39;password&#39;;&#x2F;&#x2F; 创建测试表create table test_spider (id int,username varchar(20),address varchar(128),primary key (id),key (username)) engine&#x3D;InnoDB default charset&#x3D;utf8 comment &#39;spider test base table&#39;; 测试使用 在主服务器创建访问从远程服务器的信息 123create server backend foreign data wrapper mysql options (host &#39;35.220.*.*&#39;, database &#39;test&#39;, user &#39;root&#39;, password &#39;password&#39;, port 3306);create server backend foreign data wrapper mysql options (host &#39;104.198.*.*&#39;, database &#39;backtext&#39;, user &#39;root&#39;, password &#39;password&#39;, port 3306);select * from mysql.servers; 创建单张垂直表 1234567create table test_spider (id int,username varchar(20),address varchar(128),primary key (id),key (username)) ENGINE&#x3D;SPIDER DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;server &quot;backend&quot;&#39;; hash分区表 12345678910create table test_spider_hash (id int,username varchar(20),address varchar(128),primary key (id),key (username)) ENGINE&#x3D;SPIDER DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;wrapper &quot;mysql&quot;, table &quot;test_spider&quot;&#39;PARTITION BY HASH (id)( PARTITION pt1 COMMENT &#x3D; &#39;srv &quot;backend&quot;&#39;,PARTITION pt2 COMMENT &#x3D; &#39;srv &quot;backend1&quot;&#39;) ; range分区表 12345678910create table test_spider_range (id int,username varchar(20),address varchar(128),primary key (id),key (username)) ENGINE&#x3D;SPIDER DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;wrapper &quot;mysql&quot;, table &quot;test_spider&quot;&#39;PARTITION BY range columns (id)( PARTITION pt1 values less than (100000) COMMENT &#x3D; &#39;srv &quot;backend&quot;&#39;,PARTITION pt2 values less than (200000) COMMENT &#x3D; &#39;srv &quot;backend1&quot;&#39;) ; list分区表 12345678910create table test_spider_list (id int,username varchar(20),address varchar(128),primary key (id),key (username)) ENGINE&#x3D;SPIDER DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;wrapper &quot;mysql&quot;, table &quot;test_spider&quot;&#39;PARTITION BY list columns (id)https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;ab539e9a7955( PARTITION pt1 values in (1,3,5,7,9) COMMENT &#x3D; &#39;srv &quot;backend&quot;&#39;,PARTITION pt2 values in (2,4,6,8,10) COMMENT &#x3D; &#39;srv &quot;backend1&quot;&#39;) ; 参考点这里","categories":[{"name":"server","slug":"server","permalink":"https://www.sictiy.cn/hblog/categories/server/"}],"tags":[]},{"title":"rpmdb:DBD0113","slug":"yumError","date":"2019-05-15T01:47:31.000Z","updated":"2020-01-16T03:28:47.645Z","comments":true,"path":"2019/05/15/yumError/","link":"","permalink":"https://www.sictiy.cn/hblog/2019/05/15/yumError/","excerpt":"","text":"问题1234567error: rpmdb: BDB0113 Thread/process 13173/139999979816768 failed: BDB1507 Thread died in Berkeley DB libraryerror: db5 error(-30973) from dbenv-&gt;failchk: BDB0087 DB_RUNRECOVERY: Fatal error, run database recoveryerror: cannot open Packages index using db5 - (-30973)error: cannot open Packages database in /var/lib/rpmCRITICAL:yum.main:Error: rpmdb open failed 解决：重建数据库1234cd /var/lib/rpmlsrm -rf __db*rpm --rebuilddb","categories":[{"name":"server","slug":"server","permalink":"https://www.sictiy.cn/hblog/categories/server/"}],"tags":[]},{"title":"idea文件头与方法快捷注释","slug":"idea配置文件头注释与方法注释","date":"2019-05-09T23:26:42.000Z","updated":"2020-01-16T03:28:47.644Z","comments":true,"path":"2019/05/10/idea配置文件头注释与方法注释/","link":"","permalink":"https://www.sictiy.cn/hblog/2019/05/10/idea%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%B4%E6%B3%A8%E9%87%8A%E4%B8%8E%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A/","excerpt":"","text":"文件头 设置路劲：settings -&gt; file and code templates -&gt; files -&gt; Class 设置： 123456789#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; !&#x3D; &quot;&quot;)package $&#123;PACKAGE_NAME&#125;;#end#parse(&quot;File Header.java&quot;)&#x2F;**$&#123;DESC&#125;@author $&#123;USER&#125;@date $&#123;DATE&#125; $&#123;TIME&#125;**&#x2F;public class $&#123;NAME&#125; &#123;&#125; 方法 输入/** 回车自动注释，根据设置返回值与参数值，参数为空时不设置参数，注释完光标在第二行直接输入注释信息 设置路劲：settings -&gt; Live templates -&gt; add group -&gt; add live Templates templete text: 1234** * $END$ * $PARAM$@return $RETURN$ **&#x2F; 12345- PARAM:&#96;&#96;&#96;textgroovyScript(&quot;def result&#x3D;&#39;&#39;; def params&#x3D;\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#39;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#39;, &#39;&#39;).split(&#39;,&#39;).toList(); for(i &#x3D; 0; i &lt; params.size(); i++) &#123;if(params[i] &#x3D;&#x3D; &#39;&#39;) continue; result+&#x3D;&#39;@param &#39; + params[i] + &#39; &#39; + params[i] + &#39;\\\\n * &#39;&#125;; return result&quot;, methodParameters()) RETURN: 1methodRetrunType()","categories":[],"tags":[]},{"title":"算法草稿本","slug":"algorithm","date":"2019-04-23T23:46:18.000Z","updated":"2020-01-16T03:28:47.644Z","comments":true,"path":"2019/04/24/algorithm/","link":"","permalink":"https://www.sictiy.cn/hblog/2019/04/24/algorithm/","excerpt":"","text":"卡特兰数 应用 入栈出栈顺序：1 -1 1 1 -1 1 … &gt; 0 折线法证明结果为： c(2n, n-1) 递归式满足：fn = f(1)f(n-1) + f(2)*f(n-2)…f(n-1)f(1) 可求解得出 fn = c(2n ,n) / n+1 母函数（生成函数） 二项式定理 隔板法 公式：fn = c(2n, n) / n+1 = c(2n, n) - c(2n, n-1) 例题 三角形问题 树 二叉树 avl树 单旋转 双旋转 红黑树 b树 字典树 哈希树 树状数组 从上往下建树，第一层为2^n,之后为空白处开始加2^n 求和：二进制数每次去掉最后一个1，累加 去掉最后一个1: a = x- (x &amp; (-x)) 更新第x个数，则需要更新x对应的二进制数最后一个1代表数加该数 求和结果为: a = x + ( x &amp; (-x)) 建树： 从第一个位置开始更新 对1…n 的每个数: 1234j := i + ( i &amp; -i )if i &lt; n + 1 &#123; bit[j] += bit[i]&#125; 线段树 完全二叉树 叶子节点为数据节点，中间节点为对应范围的最小值\\最大值\\范围和 并查集 pre数组存每个点的前置节点 判断一个点与另一个点是否在同一个集只需判断根节点是否相同 连通两个点只需设置其中一个点的根节点的前置节点为另一个点的根节点 路劲压缩，查找根节点时把当前节点的前置节点设置为根节点 食物链问题 图 prim最小生成树算法 多源最短路径 单源最短路径 算法 大整数相乘 tim排序 移棋子问题 两个组合计算间隔数 所有间隔数转化为nim游戏 所有数字求异或，结果为0比输，不为0有必胜策略设为k 必胜策略为：将任意在k的最高位为1的数与k异或取代改数","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://www.sictiy.cn/hblog/categories/algorithm/"}],"tags":[]},{"title":"Idea插件开发记录","slug":"idea插件开发记录","date":"2019-04-18T07:24:47.000Z","updated":"2020-01-16T03:28:47.644Z","comments":true,"path":"2019/04/18/idea插件开发记录/","link":"","permalink":"https://www.sictiy.cn/hblog/2019/04/18/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"环境 下载idea社区版 配置jdk 配置IntelliJ Platform Plugin Sdk Project Structure-&gt;sdks: 点击+，选择intellij…按提示继续，目录选择社区版安装路径就好 导入idea源码：选择sourcePath-&gt;+. 创建简单工程 create new project -&gt; intellij platform plugin 项目结构： plugin srcresources META_INF plugin.xml src为源码目录，plugin.xml为配置文件，需要在这里添加自己实现的action service等 插件入口 插件入口即在idea上部分菜单栏加入一个按钮，点击按钮则运行插件 继承抽象类AnAction， 实现actionPerformed方法： 1234567public class MyAction extends AnAction &#123; @Override // start方法，就类似于了平时的main方法 public void actionPerformed(@NotNull AnActionEvent e) &#123; com.myPlugin.Main.start(); &#125;&#125; 配置plugin.xml 1234&lt;action class=\"com.myPlugin.MyAction\" text=\"myPlugin\" id=\"myPlugin\"&gt; &lt;add-to-group group-id=\"ToolsMenu\" anchor=\"first\"/&gt;&lt;/action&gt;&lt;!-- add-to-group 定义插件的入口放在菜单的哪个菜单项下面，anchor定义插入的位置--&gt; 持久化 需要实现PersistenStateComponent接口 12345678910111213141516171819202122232425@State(name = \"myName\", storages = &#123;@Storage(\"myName.xml\")&#125;)public class MyState implements PersistentStateComponent&lt;Config&gt; &#123; private Config config; public static MyState getInstance()&#123; return ServiceManager.getService(MyState.class); &#125; @Nullable @Override // getState获取到的bean会自动保存 public Config getState() &#123; return config; &#125; @Override // 自动从文件中加载bean public void loadState(@NotNull Config state) &#123; config = state; &#125; public void setConfig(Config config) &#123; this.config = config; &#125;&#125; plugin.xml中配置： 12&lt;applicationService serviceInterface=\"com.myPlugin.MyState\" serviceImplementation=\"com.myPlugin.MyState\"/&gt; 配置入口 实现SearchableConfigurable即可在setting中增加一个配置界面，需要实现的方法有： createComponent(): 配置界面的ui，可以使用可使用工具编写 isModified(): 影响界面中应用按钮是否可点击 apply(): 点击应用按钮时调用 plugin.xml中配置： 12&lt;applicationConfigurable instance=\"com.myPlugin.MyConfigurable\"/&gt; idea中swing可视化 New -&gt; Gui Form 打开myGui.form添加部件，监听等 完成后打开同级目录的myGui.java 右键 -&gt; generate -&gt; form main，如果提示the form bound to…, 需要回到gui designer 给跟jpanel设置一个名字","categories":[],"tags":[]},{"title":"go学习笔记","slug":"study-go","date":"2019-04-08T10:30:15.000Z","updated":"2020-01-16T03:28:47.645Z","comments":true,"path":"2019/04/08/study-go/","link":"","permalink":"https://www.sictiy.cn/hblog/2019/04/08/study-go/","excerpt":"","text":"环境 windows + goland 官网下载go、goland 安装后在goland中 settings-&gt;go-&gt;goroot gopath 设置环境变量 导入第三方包 go get -u github.com/golang/protobuf/protoc-gen-go (protobuf) go get -u github.com/google/flatbuffers/go (flatbuffer) 基本语法 基本结构 package 当前包 import 导入包 (不允许循环导包，如a import b、b import a，设计包时需确定每个包的作用，包与包之间低耦合) 基本语法 函数与方法： 123 func (this* StructName) functionName(paramLists ...) returnList ... &#123;&#125;\\\\ 关键字 (接受者) 函数名 (参数列表) 返回值列表 &#123; 函数体&#125; 变量与初始化： 12var varName uint32varName := 21 常量：const 数据结构初始化： make() 可见性： 首字母大写pulic， 小写private 指针与实例：与c++相似，但都通过点访问成员 数据结构 数组：定长 切片：不定长，需要 map range：主要用在for循环中 结构体指针与数组指针转换： 1pBytes := (*[size]byte)(unsafe.Pointer(&amp;myStruct)) 接口与类 类与实例 类用struct实现 没有继承，只有组合，类似于继承： 123type extendStruct struct&#123; baseStruct&#125; 类方法需要修改类成员时，方法接收者需要是指针 接口 interface , 通过实现接口中的方法实现接口，不显式通过关键字声明实现 类与接口指针 结构的方法集只包含接收者为结构类型的方法，结构体指针的方法集同时包含接受者为结构体类型与结构体指针类型的方法 结构体的方法，只能通过结构体指针访问，但是如果结构是可被寻址的，那通过结构体访问方式将转化为通过结构体指针访问 接口的内部实现为type加value，type为value的类型，value为结构体指针。所以通过接口访问方法实际就是通过结构体指针访问 接口判等：需要type与value都相等，value通过指针对于的地址的值判断 接口内的指针可以直接与对于的结构体指针判等 协程与chan 基本用法 go func 新建一个协程运行函数func，运行完func后协程结束 var myChan chan type 一个可传输type的管道 &lt;- myChan 从myChan中读取一个值，如果myChan未写入过值则阻塞 myChan &lt;- 写入一个值到myChan，如果myChan空间不足（上个写入的值未被读取）则阻塞 chan&lt;- chan&lt;- int &lt;-符号优先和左边的结合 chan type 需要make后使用，可通过make(chan type, size) 指定容量 select语句：从所有case语句中的chan中读取一个值，都不能读取则阻塞 可以使用time.after()设置超时，该函数返回一个 &lt;-chan Time 类型的变量，一定时间后该管道可读 ticker 定时触发器，以一定间隔往chan中写入值 range遍历chan：不断从chan中读，直到chan关闭 错误与异常 错误与异常 错误是程序的一部分，异常不是 有错误时程序正常运行，相当于操作的错误码，逐层返回直到被处理即可 异常标志着程序运行在非正常状态，需要特殊处理 错误处理 将错误放在返回值的最后返回，由调用方判断是否有出错 异常处理 defer 类似于trycatch中的final，会在函数执行完之后马上调用，可以再defer函数中写资源释放代码，存在多个defer时，按程序执行顺序的反顺序执行 panic 程序运行到panic说明程序异常，当前函数马上停止执行，如果有defer函数，则执行defer recover 恢复函数，go中用于处理panic的函数，recover的返回值未panic的传入值，如果panic不被处理将网上转递，如果一直不被处理，程序将停止运行 包管理 待更新…","categories":[{"name":"go","slug":"go","permalink":"https://www.sictiy.cn/hblog/categories/go/"}],"tags":[]},{"title":"NOMINMAX问题","slug":"NOMINMAX问题","date":"2019-03-19T10:00:00.000Z","updated":"2020-01-16T03:28:47.644Z","comments":true,"path":"2019/03/19/NOMINMAX问题/","link":"","permalink":"https://www.sictiy.cn/hblog/2019/03/19/NOMINMAX%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题 更新代码后发现flatbuffer编译不过，flatbuff.h等出现大量报错。 解决过程 配置NOMINMAX 咨询组内服务器大佬，需要在vs修改宏定义，增加NOMINMAX定义，原因是std的minmax定义与windows的有冲突。修改位置为： project property pages configuration properties c/c++ preprocessor preprocessor definitions 尝试重新编译：flatbuffer部分成功编译，但出现了第二个问题，gdiplustypes.h出现编译出错，提示min，max未定义。 夏继尔尝试 在stdafx.h最后面定义宏min与max： 1234567#ifndef min#define min(a,b) (((a) &lt; (b)) ? (a) : (b))#endif#ifndef max#define max(a,b) (((a) &gt; (b)) ? (a) : (b))#endif 尝试重新编译：并没有卵用，gdi报错还是在。 在stdafx.h中取消定义宏，去掉原来配置的NOMINMAX宏： 1234567#ifdef min#undef min#endif#ifdef max#undef max#endif 结果还是一样，flatbuffer报错。 整理思路经过上面的尝试及百度google一番搜索先整理一下思路： flatbuffer需要std的宏，所以需要定义NOMINMAX宏取消windows的宏 gdiplus需要windows的宏，不能取消windows的宏 stdafx.h会预编译mfc标准头文件，所以gdiplus在编译stdafx.h期间编译，这段时间需要windows的宏 flatbuffer在预编译之后编译，不需要windows的宏 只需要保持windows的宏定义仅仅在编译stdafx.h期间存在就可以解决问题 继续尝试 配置NOMINMAX 在stdafx.h中将定义minmax的宏放到最前面，确保gdi编译时存在minmax的宏编译：部分flatbuffer报错，gdi没有报错，说明stdafx.h中定义的宏影响达到了flatbuffer的编译 在stdafx.h最后面取消定义宏，确保不影响gdi的前提下使flatbuffer编译时不存在minmax宏。再编译：ok。 最后尝试去掉NOMINMAX的宏，stdafx.h保持上面的修改编译：flatbuffers依然报错。 学习","categories":[{"name":"c++","slug":"c","permalink":"https://www.sictiy.cn/hblog/categories/c/"}],"tags":[]},{"title":"记录一波配置https","slug":"记录一波配置https","date":"2019-03-17T13:00:00.000Z","updated":"2020-01-16T03:28:47.645Z","comments":true,"path":"2019/03/17/记录一波配置https/","link":"","permalink":"https://www.sictiy.cn/hblog/2019/03/17/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%B3%A2%E9%85%8D%E7%BD%AEhttps/","excerpt":"","text":"申请ssl证书 申请腾讯的免费ssl证书 点击腾讯云免费ssl证书 申请成功后查看证书相关参数 手动验证dns服务器 申请一个域名 根据申请ssl证书处的提示添加一条记录配置相应参数 等验证通过下载ssl文件 一段时间以后收到邮件提示验证通过 此时回到申请ssl的网站，可以下载ssl证书 编译安装环境为 centos7，可以直接yum安装nginx 1sudo yum install nginx 将上一步下载的ssl文件移动到nginx配置目录下方便配置 1mv 1_www.sictiyleon.xyz_bundle.crt /etc/nginx/ssl/ nginx配置新建配置文件 1vim /etc/nginx/conf.d/www.sictiyleon.xyz 主要内容为： 12345678910111213141516171819202122232425262728293031323334server &#123; listen 80; listen 443 ssl; server_name www.sictiyleon.xyz; charset utf-8; ssl on; #ssl配置 ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;1_www.sictiyleon.xyz_bundle.crt; ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;2_www.sictiyleon.xyz.key; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!ADH:!EXPORT56:RC4+RSA:+MEDIUM; location &#x2F; &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 1024m; client_body_buffer_size 128k; client_body_temp_path &#x2F;var&#x2F;data&#x2F;client_body_temp; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; proxy_temp_path &#x2F;var&#x2F;data&#x2F;proxy_temp; proxy_pass http:&#x2F;&#x2F;127.0.0.1:4000; &#125;&#125; 启动nginx启动nginx 1systemctl restart nginx 启动失败，查看logs文件，发现不存在目录:/var/data/ 1mkdir /var/data 再次启动，看起来很正常。通过网址进入发现无法进去，提示5000。查看logs，有如下提示： 1*1012 socket() failed (24: Too many open files) while connecting to upstream, client: 127.0.0.1, server: www.sictiyleon.xyz, request: &quot;GET &#x2F; HTTP&#x2F;1.0&quot;, upstream: &quot;http:&#x2F;&#x2F;127.0.0.1:80&#x2F;&quot;, host: &quot;www.sictiyleon.xyz&quot; google以后得知是因为开启了selinux，于是临时关闭检验： 1setenforce 0 再次重启nginx后可顺利通过https进入网页。5-20更新，关闭selinux治标不治本，可通过如下命令解决： 12cat /var/log/audit/audit.log |grep nginx |grep denied| audit2allow -M mynginxsemodule -i mynginx.pp 完。","categories":[{"name":"配置","slug":"配置","permalink":"https://www.sictiy.cn/hblog/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[]},{"title":"测试写文章","slug":"test","date":"2019-03-17T07:50:09.000Z","updated":"2020-01-16T03:28:47.645Z","comments":true,"path":"2019/03/17/test/","link":"","permalink":"https://www.sictiy.cn/hblog/2019/03/17/test/","excerpt":"","text":"这是题目 二级标题三级标题 这样写 列表 列表 这是有序的 1 2 3","categories":[{"name":"测试","slug":"测试","permalink":"https://www.sictiy.cn/hblog/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[]}]}